// content
1. C# first iteration


// doubts
/*
  > what is type safe?, what does it mean by weakly typed and strong typed
  > refernce and value type in c#
  > record struct
  > pattern matching segment of microsoft c# documentation
*/



// C# first iteration
methods
  named arguemnts
    return_type method_name(type1 name1, type2 name2) {}
    while calling the method we can do
      method_name(name1: value1, name2: value2)
    this has the benefits
      > clearer to read
      > argument order can be change up
    it can be used in case of optional argument
    ex:
      return_type method_name(type0 name0, type1 name1 = default_value_1, type2 name2 = default_value_2) {}
      if we want to only specify value for name2, while keeping name1 as default, we will have to use named arguments because otherwise values 
      are filled in order of optional arguments
      method_name(value0, name2: value2)
    

string
  // general
  string interpolation
    if you add `$` before opening quotes of a string, you can add variables inside the string using curly braces
    ex:
      $"hello {friend_var}"

  methods that modify strings, return a new string, they dont make changes to the original string

  // properties
  string has a property Length
    string_var.Length

  // methods
  string has methods to Trim which returns a new modified string
    string_obj = string_var.Trim()
    string_obj = string_var.TrimStart()
    string_obj = string_var.TrimEnd()

  string has method to Replace a substring and return a new modified string
    string_obj = string_var.Replace(old_substr, new_substr)

  string has method to create all upper or all lower case
    string_obj = string_var.ToUpper()
    string_obj = string_var.ToLower()

  string has method to check wether a substring exists, returns a bool value
    bool_obj = string_var.Contains(substring)

  string has method to check wether string StartsWith or EndsWith specified string, return bool value
    bool_obj = string_var.StartsWith(string_instance)
    bool_obj = string_var.EndsWith(string_instance)

numbers
  // general
  to use `decimals` we need suffix `M`
  ex:
    decimal var = 1.0M

  // properties
  numbers has property MaxValue and MinValue
  ex: int
    int.MaxValue
    int.MinValue
  can do with other types as well like, double, float, int, decimal

types
  all named types are either class or struct types.
  class is a reference type
  struct is a value type
  

  ValueTuple
    these are distinct from system tuples
    ValueTuples are mutable whereas System.Tuple<> are immutable

    Value tuples can have 7 direct elements, to extend, the 8th element has to be a nested tuple

    // general
    declaration syntax
      (Type1 [field_name], Type2 [field_name]) tuple_var = (value1, value2)
      can replace with 
        var tuple_var = (value1, value2) // if field_name isn't going to be mentioned on LHS
      another way to specify the field_name is on RHS
      var tuple_var = (field_name : value_1, field_name : value_2)
  
    if no field_names are specidied, default field_name to access elements are - Item1, Item2 and so on ...
  
    to access elements
    tuple_var.field_name
  
    tuple supports `==` and `!=`
    the tuples must be of the same -arity
    the field_names dont matter, only the values are compared

    tuple supports `=`
    the tuples must be of the same -arity
    to make modifications with can use `with`
    ex:  
      var tuple_var_1 = tuple_var_2 with { field_name = value }
  
    returning tuples from methods
    (type1 [field_name], type2 [field_name]) method() {}

  record (record class and record struct)
    record class or record 
      // general
      records are immutable reference types (immutable only positional records, otherwise possible to make mutable properties) similiar classes but follow value based equality operations
  
      declaration
      public record record_var(type1 field_name, type2 field_2) // this is an example of positional records
                                                                // positional records are immutable as they as similiar to property {get; init;}
                                                                // however it is only shallow immutablility, if the positional parameter is a reference
                                                                // can cannot change the reference itself, but we can change the value being pointed to
      we can declare more memebers which can be more data elements and methods
      ex:
        public record record_var(type1 field_name, type2 field_2) // position records parameters
        {
          type3 field_name {get; set;} // the fields can be mutable, only positional paramaters are strictly immutable
          type3 field_name {get; init;}

          // any methods you want
        }
  
      shallow copying (value based) [with modification]
      record_obj = record_var [with {field1 = value, field_2 = value}] 

    record struct
      // i don't know it 

collection
  List<T>
    // general
    declaration
    ex: List<int> list_var = [1,2,3,4,5]
  
    can access individual elements using square braces
    list_var[index]

    // properties
    number of elements
    list_var.Count

    // methods
    adding and removing
    list_var.Add(element)
    list_var.Remove(element)

    finding the first occurence of an element
    list_var.IndexOf(element) // returns -1 if not found

    sorting
    list_var.Sort()

general structure
  the program starts with the static Main method or top level statements
  only one file can have top level statements
  in case of both top level statements and Main method, compiler generates a warning that the Main method will not be used as an entry point, as the top level statements are taken as the entry point

  each program consists of zero or more namespaces
  each namespace contains types like
    class
    struct
    interface
    delegate
    namespace

  the parameter `string[] args` is optional and depends upon need
  the Main method returns one of the following
    int
    void
    Task<int>
    Task
  
