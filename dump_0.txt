// content
1. C# first iteration


// doubts
/*
  > what is type safe?, what does it mean by weakly typed and strong typed
  > refernce and value type in c#
*/



// C# first iteration
string
  // general
  string interpolation
    if you add `$` before opening quotes of a string, you can add variables inside the string using curly braces
    ex:
      $"hello {friend_var}"

  methods that modify strings, return a new string, they dont make changes to the original string

  // properties
  string has a property Length
    <string_var>.Length

  // methods
  string has methods to Trim which returns a new modified string
    <string_obj> = <string_var>.Trim()
    <string_obj> = <string_var>.TrimStart()
    <string_obj> = <string_var>.TrimEnd()

  string has method to Replace a substring and return a new modified string
    <string_obj> = <string_var>.Replace(<old_substr>, <new_substr>)

  string has method to create all upper or all lower case
    <string_obj> = <string_var>.ToUpper()
    <string_obj> = <string_var>.ToLower()

  string has method to check wether a substring exists, returns a bool value
    <bool_obj> = <string_var>.Contains(<substring>)

  string has method to check wether string StartsWith or EndsWith specified string, return bool value
    <bool_obj> = <string_var>.StartsWith(<string_instance>)
    <bool_obj> = <string_var>.EndsWith(<string_instance>)

numbers
  // general
  to use `decimals` we need suffix `M`
  ex:
    decimal var = 1.0M

  // properties
  numbers has property MaxValue and MinValue
  ex: int
    int.MaxValue
    int.MinValue
  can do with other types as well like, double, float, int, decimal

types
  ValueTuple
    these are distinct from system tuples
    ValueTuples are mutable whereas System.Tuple<> are immutable

    Value tuples can have 7 direct elements, to extend, the 8th element has to be a nested tuple

    // general
    declaration syntax
      (Type1 [field_name], Type2, [field_name]) <tuple_var> = (value1, value2)
      can replace with 
        var <tuple_var> = (value1, value2) // if field_name isn't going to be mentioned on LHS
      another way to specify the field_name is on RHS
      var <tuple_var> = (field_name : value_1, field_name : value_2)
  
    if no field_names are specidied, default field_name to access elements are - Item1, Item2 and so on ...
  
    to access elements
    <tuple_var>.<field_name>
  
    tuple supports `==` and `!=`
    the tuples must be of the same -arity
    the field_names dont matter, only the values are compared
  
    returning tuples from methods
    (type1 [field_name], type2 [field_name]) method() {}
  
  
